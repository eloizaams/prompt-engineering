# Prompt Chaining Result

## SCHEMA (Generated by GPT-3.5-turbo)
```json
{
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "name": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "price": {
      "type": "number",
      "minimum": 0
    },
    "stock": {
      "type": "integer",
      "minimum": 0
    }
  },
  "required": ["name"]
}
```

## ROUTES & HANDLERS (Go) (Generated by GPT-5-mini)
Below is a concise, production-oriented design for CRUD over the provided JSON schema (I'll call the resource "Product"). It shows routes, a repository interface (for DI/testing), idiomatic Go handlers using chi, JSON decode/encode helpers, basic validation, and an example in-memory repo for testing. Keep in mind in production you'd implement a DB-backed repo (SQL/ORM/pgx, etc.), add request logging, instrumentation, tracing, auth, and more robust validation.

Routes
- GET  /products               -> list (limit/offset)
- POST /products               -> create
- GET  /products/{id}          -> get
- PUT  /products/{id}          -> replace/update
- DELETE /products/{id}       -> delete

Code

Product model + repository interface:
```go
package api

import (
	"context"
	"errors"

	"github.com/google/uuid"
)

// Product follows the provided JSON schema
type Product struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description,omitempty"`
	Price       float64   `json:"price,omitempty"`
	Stock       int       `json:"stock,omitempty"`
}

// Validation errors
var (
	ErrNotFound     = errors.New("not found")
	ErrInvalidInput = errors.New("invalid input")
)

// Repository defines persistence operations (implement in SQL, etc.)
type ProductRepo interface {
	Create(ctx context.Context, p *Product) error
	Get(ctx context.Context, id uuid.UUID) (*Product, error)
	Update(ctx context.Context, p *Product) error // returns ErrNotFound if missing
	Delete(ctx context.Context, id uuid.UUID) error
	List(ctx context.Context, limit, offset int) ([]*Product, error)
}
```

Handlers (chi router, JSON helpers, validation):
```go
package api

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

// Handlers groups dependencies
type Handlers struct {
	Repo ProductRepo
	// Logger, tracer, validator, etc. can be added here
}

// RegisterRoutes attaches handlers to a router
func (h *Handlers) RegisterRoutes(r chi.Router) {
	r.Route("/products", func(r chi.Router) {
		r.Get("/", h.List)
		r.Post("/", h.Create)
		r.Route("/{id}", func(r chi.Router) {
			r.Get("/", h.Get)
			r.Put("/", h.Update)
			r.Delete("/", h.Delete)
		})
	})
}

// ---- helpers ----
func writeJSON(w http.ResponseWriter, status int, v interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(v)
}

func writeError(w http.ResponseWriter, status int, msg string) {
	writeJSON(w, status, map[string]string{"error": msg})
}

func parseID(r *http.Request) (uuid.UUID, error) {
	idStr := chi.URLParam(r, "id")
	return uuid.Parse(idStr)
}

func validateProductInput(p *Product) error {
	if p.Name == "" {
		return errors.New("name is required")
	}
	if p.Price < 0 {
		return errors.New("price must be >= 0")
	}
	if p.Stock < 0 {
		return errors.New("stock must be >= 0")
	}
	return nil
}

// ---- handlers ----

// Create POST /products
func (h *Handlers) Create(w http.ResponseWriter, r *http.Request) {
	var in struct {
		Name        string  `json:"name"`
		Description string  `json:"description"`
		Price       float64 `json:"price"`
		Stock       int     `json:"stock"`
	}
	if err := json.NewDecoder(r.Body).Decode(&in); err != nil {
		writeError(w, http.StatusBadRequest, "invalid JSON")
		return
	}

	p := &Product{
		ID:          uuid.New(),
		Name:        in.Name,
		Description: in.Description,
		Price:       in.Price,
		Stock:       in.Stock,
	}
	if err := validateProductInput(p); err != nil {
		writeError(w, http.StatusBadRequest, err.Error())
		return
	}

	if err := h.Repo.Create(r.Context(), p); err != nil {
		// In production, differentiate DB error types (unique constraint, etc.)
		writeError(w, http.StatusInternalServerError, "could not create product")
		return
	}

	w.Header().Set("Location", fmt.Sprintf("/products/%s", p.ID.String()))
	writeJSON(w, http.StatusCreated, p)
}

// Get GET /products/{id}
func (h *Handlers) Get(w http.ResponseWriter, r *http.Request) {
	id, err := parseID(r)
	if err != nil {
		writeError(w, http.StatusBadRequest, "invalid id")
		return
	}
	p, err := h.Repo.Get(r.Context(), id)
	if err != nil {
		if errors.Is(err, ErrNotFound) {
			writeError(w, http.StatusNotFound, "product not found")
			return
		}
		writeError(w, http.StatusInternalServerError, "server error")
		return
	}
	writeJSON(w, http.StatusOK, p)
}

// Update PUT /products/{id}
func (h *Handlers) Update(w http.ResponseWriter, r *http.Request) {
	id, err := parseID(r)
	if err != nil {
		writeError(w, http.StatusBadRequest, "invalid id")
		return
	}
	var in struct {
		Name        string  `json:"name"`
		Description string  `json:"description"`
		Price       float64 `json:"price"`
		Stock       int     `json:"stock"`
	}
	if err := json.NewDecoder(r.Body).Decode(&in); err != nil {
		writeError(w, http.StatusBadRequest, "invalid JSON")
		return
	}
	p := &Product{
		ID:          id,
		Name:        in.Name,
		Description: in.Description,
		Price:       in.Price,
		Stock:       in.Stock,
	}
	if err := validateProductInput(p); err != nil {
		writeError(w, http.StatusBadRequest, err.Error())
		return
	}
	if err := h.Repo.Update(r.Context(), p); err != nil {
		if errors.Is(err, ErrNotFound) {
			writeError(w, http.StatusNotFound, "product not found")
			return
		}
		writeError(w, http.StatusInternalServerError, "could not update")
		return
	}
	writeJSON(w, http.StatusOK, p)
}

// Delete DELETE /products/{id}
func (h *Handlers) Delete(w http.ResponseWriter, r *http.Request) {
	id, err := parseID(r)
	if err != nil {
		writeError(w, http.StatusBadRequest, "invalid id")
		return
	}
	if err := h.Repo.Delete(r.Context(), id); err != nil {
		if errors.Is(err, ErrNotFound) {
			writeError(w, http.StatusNotFound, "product not found")
			return
		}
		writeError(w, http.StatusInternalServerError, "could not delete")
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

// List GET /products?limit=20&offset=0
func (h *Handlers) List(w http.ResponseWriter, r *http.Request) {
	q := r.URL.Query()
	limit := 20
	offset := 0
	if s := q.Get("limit"); s != "" {
		if v, err := strconv.Atoi(s); err == nil && v > 0 {
			limit = v
		}
	}
	if s := q.Get("offset"); s != "" {
		if v, err := strconv.Atoi(s); err == nil && v >= 0 {
			offset = v
		}
	}

	items, err := h.Repo.List(r.Context(), limit, offset)
	if err != nil {
		writeError(w, http.StatusInternalServerError, "could not list products")
		return
	}
	writeJSON(w, http.StatusOK, items)
}
```

Example in-memory repository (for tests/dev):
```go
package api

import (
	"context"
	"sync"

	"github.com/google/uuid"
)

type memRepo struct {
	mu sync.RWMutex
	m  map[uuid.UUID]*Product
}

func NewMemRepo() ProductRepo {
	return &memRepo{
		m: make(map[uuid.UUID]*Product),
	}
}

func (r *memRepo) Create(ctx context.Context, p *Product) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	// note: no uniqueness check here
	cp := *p
	r.m[p.ID] = &cp
	return nil
}

func (r *memRepo) Get(ctx context.Context, id uuid.UUID) (*Product, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	p, ok := r.m[id]
	if !ok {
		return nil, ErrNotFound
	}
	cp := *p
	return &cp, nil
}

func (r *memRepo) Update(ctx context.Context, p *Product) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	if _, ok := r.m[p.ID]; !ok {
		return ErrNotFound
	}
	cp := *p
	r.m[p.ID] = &cp
	return nil
}

func (r *memRepo) Delete(ctx context.Context, id uuid.UUID) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	if _, ok := r.m[id]; !ok {
		return ErrNotFound
	}
	delete(r.m, id)
	return nil
}

func (r *memRepo) List(ctx context.Context, limit, offset int) ([]*Product, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	out := make([]*Product, 0, len(r.m))
	for _, p := range r.m {
		cp := *p
		out = append(out, &cp)
	}
	// naive offset/limit â€” in prod we'd sort and use DB pagination
	start := offset
	if start > len(out) {
		start = len(out)
	}
	end := start + limit
	if end > len(out) {
		end = len(out)
	}
	return out[start:end], nil
}
```

Wiring in main:
```go
package main

import (
	"net/http"
	"time"

	"example.com/project/api"

	"github.com/go-chi/chi/v5"
)

func main() {
	r := chi.NewRouter()
	// add middleware: logging, recoverer, timeout, requestid, auth, rate limit...
	// r.Use(middleware.RequestID)
	// r.Use(middleware.Logger)
	// r.Use(middleware.Recoverer)
	// r.Use(middleware.Timeout(60 * time.Second))

	repo := api.NewMemRepo()
	h := &api.Handlers{Repo: repo}
	h.RegisterRoutes(r)

	srv := &http.Server{
		Addr:         ":8080",
		Handler:      r,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
	}
	if err := srv.ListenAndServe(); err != nil {
		panic(err)
	}
}
```

Notes / Next steps
- Replace memRepo with SQL repo (use context timeouts and transactions).
- Add schema validation lib or struct tags (go-playground/validator) for richer errors.
- Add logging, metrics, auth, rate limiting, request/response size limits.
- Consider PATCH for partial updates, optimistic locking (ETag/version) for concurrency control.

If you want, I can:
- provide a SQL (postgres) repo implementation,
- add request validation with go-playground/validator and error mapping,
- add tests for handlers.

## COMMIT (Generated by GPT-4o-mini)
```
feat(api): implement CRUD operations for Product resource with in-memory storage
```

---
**Pipeline Models:**
- Step 1: GPT-3.5-turbo
- Step 2: GPT-5-mini
- Step 3: GPT-4o-mini  

